set
a = {} # Пустое множество
b = set() # Пустое множество
c = frozenset() # Пустое неизменяемое множество
a = {1, 1.1, 'a', (1, 1.1), None, True, print} # Множество в котором:целое;вещественное;строковое;кортеж;пустой тип;булевой тип;встроенная функция.
a =  {1, 1.1, [1, 2]} # Обмануть встроенные проверки добавлением списка в кортеж не получится, возникнет ошибка.
a = [1, 'abc',1] # Раньше я был списком
set(a) # {1, 'abc'}, но а остался списком
b = set('слово') # {'с', 'л', 'о', 'в',}
c =  frozenset('hello') # {'h', 'e', 'l', 'o'}
d = set([1, [2.1], 1]) # Ошибка, внутри есть изменяемый тип
a = {1, 1.1, 'a'}
a.add('привет') # Теперь в a {1, 1.1, 'a', 'привет'}
a = {1, 2, 3}
a.update({5,2}) # Добовляет значения(объекты), во множество из другого множества.Помним, что во множестве элементы уникальные. Теперь a {1, 2, 3, 5}
a = {1, 1.1, 'a'}
a[0] # Ошибка
a = {1, 2, 3} # Теперь 'a' равно {1, 2, 3}
a = {1, 2, 3}
a.clear() # Очищает множество, делая его пустым.Теперь а {}
a = {1, 2, 3, 4}
a.pop() # 1.Возвращеат элемент из множества и удаляет его.Теперь а {1, 3, 4}
a.remove(3) # Удаление передаваемого элемента (например 3) из множества. Теперь а {2, 4}. Если такого элемента не существует, то вызовется ошибка.
a.discard(5) # None. Тоже удаляет значение или объект, но вызывает ошибку, если данного значения нет во множестве,а по умолчанию возвращает None.а остался {2, 4}
help(set) # Информация о множествах
a = {1, 2, 3}
a.copy() # Возвращает копию множества.
a.isdisjoint({4, 5, 6}) # True. Проверяет,что между множествами нет общих элементов.
a.issubset({4, 3, 1, 2}) # True. Проверяет, что множество а является подмножеством (находится в) {4, 3, 1, 2}.
a.issuperset({2, 1}) # True. Проверяет, что множество а является охватывающим множеством {2, 1} т.е что {2, 1} содержится в множестве а
a = {'сыр', 'помидор', 'молоко'}
b = {'яблоко', 'хлеб', 'молоко'}
a.intersection(b) # {'молоко'}. Возвращает множество в котором общее между двумя множествами
a.intersection_update(b) # Записывает в множество а результат метода intersection. Теперь а {'молоко'}
a = {'сыр', 'помидор', 'молоко'}
b = {'яблоко', 'хлеб', 'молоко'}
a.union(b) # {'сыр', 'помидор', 'молоко' 'яблоко', 'хлеб'}
a.union_update(b) # Записывает результат метода union.


tuple
a = [1, 2.1, 3] # Раньше я был списком
tuple(a) # (1, 2.1, 3),о а остался списком
b = tuple # ('a', 'b', 'c')